'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var PREFIX = exports.PREFIX = 'mongo:';
var base64 = exports.base64 = function base64(str) {
  return new Buffer(str, 'ascii').toString('base64');
};
var unbase64 = exports.unbase64 = function unbase64(b64) {
  return new Buffer(b64, 'base64').toString('ascii');
};

/**
 * Rederives the offset from the cursor string
 */
var cursorToOffset = exports.cursorToOffset = function cursorToOffset(cursor) {
  return parseInt(unbase64(cursor).substring(PREFIX.length), 10);
};

/**
 * Given an optional cursor and a default offset, returns the offset to use;
 * if the cursor contains a valid offset, that will be used, otherwise it will
 * be the default.
 */
var getOffsetWithDefault = exports.getOffsetWithDefault = function getOffsetWithDefault(cursor, defaultOffset) {
  if (cursor === undefined || cursor === null) {
    return defaultOffset;
  }
  var offset = cursorToOffset(cursor);
  return isNaN(offset) ? defaultOffset : offset;
};

/**
 * Creates the cursor string from an offset.
 */
var offsetToCursor = exports.offsetToCursor = function offsetToCursor(offset) {
  return base64(PREFIX + offset);
};

// improve this
var getTotalCount = exports.getTotalCount = function () {
  var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(_ref2) {
    var cursor = _ref2.cursor;
    var clonedCursor;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            clonedCursor = cursor.model.find().merge(cursor);
            _context.next = 3;
            return clonedCursor.count();

          case 3:
            return _context.abrupt('return', _context.sent);

          case 4:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, undefined);
  }));

  return function getTotalCount(_x) {
    return _ref.apply(this, arguments);
  };
}();

var calculateOffsets = exports.calculateOffsets = function calculateOffsets(_ref3) {
  var args = _ref3.args,
      totalCount = _ref3.totalCount;
  var after = args.after,
      before = args.before;
  var first = args.first,
      last = args.last;

  // Limit the maximum number of elements in a query

  if (!first && !last) first = 10;
  if (first > 1000) first = 1000;
  if (last > 1000) last = 1000;

  var beforeOffset = getOffsetWithDefault(before, totalCount);
  var afterOffset = getOffsetWithDefault(after, -1);

  var startOffset = Math.max(-1, afterOffset) + 1;
  var endOffset = Math.min(totalCount, beforeOffset);

  if (first !== undefined) {
    endOffset = Math.min(endOffset, startOffset + first);
  }
  if (last !== undefined) {
    startOffset = Math.max(startOffset, endOffset - last);
  }

  var skip = Math.max(startOffset, 0);

  var limit = endOffset - startOffset;

  return {
    first: first,
    last: last,
    before: before,
    after: after,
    skip: skip,
    limit: limit,
    beforeOffset: beforeOffset,
    afterOffset: afterOffset,
    startOffset: startOffset,
    endOffset: endOffset
  };
};

var getPageInfo = exports.getPageInfo = function getPageInfo(_ref4) {
  var edges = _ref4.edges,
      before = _ref4.before,
      after = _ref4.after,
      first = _ref4.first,
      last = _ref4.last,
      afterOffset = _ref4.afterOffset,
      beforeOffset = _ref4.beforeOffset,
      startOffset = _ref4.startOffset,
      endOffset = _ref4.endOffset,
      totalCount = _ref4.totalCount;

  var firstEdge = edges[0];
  var lastEdge = edges[edges.length - 1];
  var lowerBound = after ? afterOffset + 1 : 0;
  var upperBound = before ? Math.min(beforeOffset, totalCount) : totalCount;

  return {
    startCursor: firstEdge ? firstEdge.cursor : null,
    endCursor: lastEdge ? lastEdge.cursor : null,
    hasPreviousPage: last !== null ? startOffset > lowerBound : false,
    hasNextPage: first !== null ? endOffset < upperBound : false
  };
};

var connectionFromMongoCursor = function () {
  var _ref5 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(_ref6) {
    var cursor = _ref6.cursor,
        context = _ref6.context,
        _ref6$args = _ref6.args,
        args = _ref6$args === undefined ? {} : _ref6$args,
        loader = _ref6.loader;

    var clonedCursor, totalCount, _calculateOffsets, first, last, before, after, skip, limit, beforeOffset, afterOffset, startOffset, endOffset, slice, edges;

    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            clonedCursor = cursor.model.find().merge(cursor);
            _context2.next = 3;
            return getTotalCount({
              cursor: clonedCursor
            });

          case 3:
            totalCount = _context2.sent;
            _calculateOffsets = calculateOffsets({ args: args, totalCount: totalCount }), first = _calculateOffsets.first, last = _calculateOffsets.last, before = _calculateOffsets.before, after = _calculateOffsets.after, skip = _calculateOffsets.skip, limit = _calculateOffsets.limit, beforeOffset = _calculateOffsets.beforeOffset, afterOffset = _calculateOffsets.afterOffset, startOffset = _calculateOffsets.startOffset, endOffset = _calculateOffsets.endOffset;

            // If supplied slice is too large, trim it down before mapping over it.

            clonedCursor.skip(skip);
            clonedCursor.limit(limit);

            //avoid large objects retrieval from collection
            _context2.next = 9;
            return clonedCursor.select({ _id: 1 }).exec();

          case 9:
            slice = _context2.sent;
            edges = slice.map(function (value, index) {
              return {
                cursor: offsetToCursor(startOffset + index),
                node: loader(context, value._id)
              };
            });
            return _context2.abrupt('return', {
              edges: edges,
              count: totalCount,
              pageInfo: getPageInfo({
                edges: edges,
                before: before,
                after: after,
                first: first,
                last: last,
                afterOffset: afterOffset,
                beforeOffset: beforeOffset,
                startOffset: startOffset,
                endOffset: endOffset,
                totalCount: totalCount
              })
            });

          case 12:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, undefined);
  }));

  return function connectionFromMongoCursor(_x2) {
    return _ref5.apply(this, arguments);
  };
}();

exports.default = connectionFromMongoCursor;