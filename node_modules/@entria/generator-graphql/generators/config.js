'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getConfigDir = exports.getCreateGraphQLConfig = exports.DIRECTORY_TYPE = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _lodash = require('lodash.merge');

var _lodash2 = _interopRequireDefault(_lodash);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _pkgDir = require('pkg-dir');

var _pkgDir2 = _interopRequireDefault(_pkgDir);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const rootPath = _pkgDir2.default.sync('.') || '.';

let cacheConfig = null;

/**
 * Parse `.graphqlrc` config file and retrieve its contents
 * @param filePath {string} The path of the config file
 * @returns {*}
 */
const parseConfigFile = filePath => {
  const config = JSON.parse(_fs2.default.readFileSync(filePath, 'utf8'));

  const directories = Object.keys(config.directories).reduce((data, directory) => {
    if (directory === DIRECTORY_TYPE.SOURCE) {
      return _extends({}, data, {
        [directory]: `${rootPath}/${config.directories[directory]}`,
        [DIRECTORY_TYPE.SRC]: config.directories.source
      });
    }

    return _extends({}, data, {
      [directory]: `${config.directories.source}/${config.directories.module}/${config.directories[directory]}`
    });
  }, {});

  return _extends({}, config, {
    directories: _extends({}, config.directories, directories)
  });
};

const DIRECTORY_TYPE = exports.DIRECTORY_TYPE = {
  SOURCE: 'source',
  SRC: 'src',
  MODULE: 'module',
  CONNECTION: 'connection',
  LOADER: 'loader',
  MODEL: 'model',
  MUTATION: 'mutation',
  MUTATION_TEST: 'mutation_test',
  TYPE: 'type',
  TYPE_TEST: 'type_test'
};

/**
 * Get the `.graphqlrc` config file
 * @returns {object} The content of the config
 */
const getCreateGraphQLConfig = exports.getCreateGraphQLConfig = () => {
  // if (cacheConfig) return cacheConfig;

  // Use default config
  const defaultFilePath = _path2.default.resolve(`${__dirname}/graphqlrc.json`);

  const config = parseConfigFile(defaultFilePath);

  try {
    // Check if there is a `.graphqlrc` file in the root path
    const customConfig = parseConfigFile(`${rootPath}/.graphqlrc`);

    (0, _lodash2.default)(config, customConfig);

    cacheConfig = config;

    // If it does, extend default config with it, so if the custom config has a missing line
    // it won't throw errors
    return config;
  } catch (err) {
    cacheConfig = config;
    // Return the default config if the custom doesn't exist
    return config;
  }
};

/**
 * Get a directory from the configuration file
 * @param directory {string} The name of the directory, e.g. 'source'/'mutation'
 * @returns {string} The directory path
 */
const getConfigDir = exports.getConfigDir = directory => getCreateGraphQLConfig().directories[directory];